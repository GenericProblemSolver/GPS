/*
 * Copyright 2016  Generic Problem Solver Project
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package gps.bytecode.symexec;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import com.sun.tools.classfile.ConstantPool;
import com.sun.tools.classfile.Instruction;

import gps.bytecode.disassemble.ClassDisassembler;
import gps.bytecode.disassemble.DBlock;
import gps.bytecode.disassemble.DMethod;
import gps.bytecode.disassemble.MethodRef;
import gps.bytecode.exceptions.IncoherentBytecodeException;
import gps.bytecode.expressions.Expression;
import gps.util.Tuple;

/**
 * This class describes the state of the virtual machine during symbolic execution of a codeblock
 */
public class Context {

    /**
     * stack of the virtual machine
     */
    public final Stack<Expression> stack = new Stack<>();

    /**
     * local variables of virtual machine
     */
    public final Expression[] locals = new Expression[256];

    /**
     * static variables of virtual machine
     */
    public final Map<FieldRef, Expression> statics = new HashMap<>();

    /**
     * Expression representing the state of the heap (with put-Operations)
     */
    public Expression heap;

    /**
     * Expression representing the highest address + 1 on the heap (used for allocating new objects)
     */
    public Expression heapsize;

    /**
     * symbolic execution context
     */
    public final SymbolicExec symbolicExec;

    /**
     * SEFunction that is generated by symbolic execution
     */
    final SEFunction invoker;

    /**
     * Previous "Stackframe" of execution. Contexts of the same method have the
     * same previousFrame
     */
    public final Context previousFrame;

    /**
     * Instruction offset where exection continues after returning from an
     * invoke
     */
    public final int nextAddress;

    public Context(final SymbolicExec symExec, SEFunction invoker,
            Context previousFrame) {
        this.symbolicExec = symExec;
        this.invoker = invoker;
        this.previousFrame = previousFrame;

        Instruction instr = invoker.dBlock.instructions
                .get(invoker.dBlock.instructions.size() - 1);
        nextAddress = instr.getPC() + instr.length();
    }

    /**
     * Returns the ConstantPool the current symbolic Execution Context uses
     * 
     * @return
     */
    public ConstantPool getConstantPool() {
        return invoker.dBlock.parentMethod.getConstantPool();
    }

    /**
     * Returns the SEFunction that represents the bytecode of the local Method
     * at the given ProgramCounter(PC)
     * 
     * @param address
     * @return
     */
    public SEFunction getSEFunctionforPC(int address) {
        DBlock block = invoker.dBlock.parentMethod.getBlock(address);

        if (block == null) {
            throw new IncoherentBytecodeException(
                    "Cannot find SEFunction for address " + address);
        }
        Tuple<DBlock, Context> key = new Tuple<>(block, previousFrame);

        // Look for a function for the correct code block
        if (symbolicExec.knownSEFuntions.containsKey(key)) {
            return symbolicExec.knownSEFuntions.get(key);
        } else {
            return symbolicExec.constructFunction(block, this);
        }
    }

    /**
     * Generates a SEFunction for the Method specified by a MethodRef with an number of parameters
     * Since the Method may be virtual, a object type is required
     * 
     * @param mref
     *            Reference to a method
     * @param exps
     *            the parameters for the invoked Method and the Object it was
     *            invoked on
     * @return the SEFunction of the first Block of the specified Method
     */
    public SEFunction getSEFunctionForMethod(MethodRef mref,
            Expression[] exps) {
        DMethod m = null;
        if (symbolicExec.disassembledMethods.containsKey(mref)) {
            m = symbolicExec.disassembledMethods.get(mref);
        } else {
            m = ClassDisassembler.disassembleMethod(mref);
            symbolicExec.disassembledMethods.put(mref, m);
        }
        return symbolicExec.constructInvFunction(m, exps, this);
    }

    /**
     * Returns the runtimetype-id of a class in the current context
     * @param c
     * @return
     */
    public int getTypeId(Class<?> c) {
        if (!symbolicExec.typeIds.containsKey(c)) {
            symbolicExec.typeIds.put(c, symbolicExec.nextId);
            symbolicExec.reverseTypeIds.put(symbolicExec.nextId, c);
            symbolicExec.inheritMap.put(symbolicExec.nextId, new ArrayList<>());
            symbolicExec.nextId += 1;

            //We need to do some bookkeeping to keep the inheritance maps up to date
            for (Class<?> c2 : symbolicExec.typeIds.keySet()) {
                if (c == c2) {
                    continue;
                }
                // c2 is a superclass of c, for instanceof c2 we need to check instanceof c aswell
                if (c2.isAssignableFrom(c)) {
                    symbolicExec.inheritMap.get(symbolicExec.typeIds.get(c2))
                            .add(symbolicExec.typeIds.get(c));
                }
                // c is a superclass of c2, for instanceof c we need to check instanceof c2 aswell
                if (c.isAssignableFrom(c2)) {
                    symbolicExec.inheritMap.get(symbolicExec.typeIds.get(c))
                            .add(symbolicExec.typeIds.get(c2));
                }
            }
        }
        return symbolicExec.typeIds.get(c);
    }

    /**
     * Returns all runtimetype-ids that are subclasses of a given typeid
     * @param typeid
     * @return
     */
    public List<Integer> getSubTypes(int typeid) {
        return symbolicExec.inheritMap.get(typeid);
    }

    /**
     * Returns all Classes that are used in the current context
     * @return
     */
    public Collection<Class<?>> getUsedTypes() {
        return symbolicExec.typeIds.keySet();
    }
}
