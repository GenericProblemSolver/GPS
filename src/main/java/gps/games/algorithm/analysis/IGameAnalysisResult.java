/*
 * Copyright 2016  Generic Problem Solver Project
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package gps.games.algorithm.analysis;

import java.util.Optional;

import gps.games.util.GameTree;
import gps.util.Tuple;

/**
 * Game Analysis Result. Provides various informations about the analysed
 * problem.
 * 
 * @author haker@uni-bremen.de
 * @author Fabian
 *
 * @param <T>
 *            The type of the problem class
 */
public interface IGameAnalysisResult {

    /**
     * Contains the tree that was created by the analyzer.
     * 
     * @return The tree created by the analyzer.
     * @deprecated This serializes badly... Move to GamesModule?
     */
    @Deprecated
    public GameTree<?> getTree();

    /**
     * Returns the optional tuple saving the currently saved utility range for
     * this object. The first value contains the minimum, the second value the
     * maximum utility value found in the analysis. Will only be set if the
     * problem contained a utility method.
     * 
     * @return The tuple containing the utility range found in the analysis.
     *         Will be Optional.empty() if no utility method was found. Does
     *         never contain values < 0. Minimum will always be <= maximum.
     */
    public Optional<Tuple<Double, Double>> getUtilityRange();

    /**
     * Returns the percent value of paths that terminated.
     * 
     * @return The percentage of paths that terminated in the analysis. Will
     *         should be between 0 and 1 since it represents a percental value.
     */
    public Double getTerminationRate();

    /**
     * Returns the amount of players found in the analysis. Will contain
     * Optional.empty() if it hasnt been set yet.
     * 
     * @return The amount of players found in the analysis, or Optional.empty()
     *         if no corresponding method was found or it hasnt been set yet.
     */
    public Optional<Integer> getPlayerNumber();

    /**
     * Returns the tuple saving the depth range for this object. The first value
     * contains the minimum, the second value the maximum depth found in the
     * analysis.
     * 
     * @return The tuple containing the depth range found in the analysis. Does
     *         never contain values < 0. Minimum will always be <= maximum.
     */
    public Tuple<Integer, Integer> getDepthRange();

    /**
     * Returns the average depth found in the analysis of the given problem.
     * 
     * @return The depth averaged over all nodes that had a true terminal test
     */
    public Double getAvgDepth();

    /**
     * Returns the average branching factor found in the analysis of the given
     * problem.
     * 
     * @return The branching factor averaged over all nodes generated by the
     *         analyser.
     */
    public Double getAvgBranchingFactor();

    /**
     * Return the time used for the analysis averaged over all available threads
     * 
     * @return The average time needed for a thread to complete the analysis, or
     *         until it was interrupted
     */
    public Double getAvgTime();

    /**
     * Returns the average memory used per node in the given tree
     * 
     * @return The memory per node in bytes
     */
    public Optional<Double> getMemoryPerNode();

    /**
     * Returns the amount of nodes visited by all threads combined. 
     * 
     * @return The amount of nodes the cpu got to calculate before being
     *         interrupted or completing the task.
     */
    public Integer getCompletedNodeCount();

    /**
     * Returns an array of doubles containing all values to be used in the
     * classification.
     * 
     * @return The array contains all for training appropriately useable values
     *         found in the analysis. A value that has not been set will be
     *         Double.NaN. This can happen if the corresponding method to
     *         calculate the value was not available to the analyser.
     */
    public Double[] getClassificationVector();

    /**
     * Size of the array returned by {@link #getClassificationVector()} vector.
     */
    public static final int VECTOR_SIZE = 11;

}
